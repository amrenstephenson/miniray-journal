# Log Entry 0 - (9 March 2022)
[![Image of a ray traced sphere.](https://upload.wikimedia.org/wikipedia/commons/5/56/POV-Ray_przyklad.jpg)](https://commons.wikimedia.org/wiki/File:POV-Ray_przyklad.jpg)
\[Image credit: [Semu](https://en.wikipedia.org/wiki/pl:User:Semu)]

## What are my objectives?
Overall, I want to learn about the implementation of ray-based [rendering](https://en.wikipedia.org/wiki/Rendering_(computer_graphics)) algorithms and computer graphics in general. I'm interested in this because, while I have created many 3D games, I have never written the rendering code myself. As such, rendering has often remained a mysterious "black box" where you send in [3D models](https://en.wikipedia.org/wiki/3D_modeling#Models) and get images back, and my hope is that this will give me the opportunity to peek inside said box.

## What have I done?
I have decided to work on a collaborative [open source](https://en.wikipedia.org/wiki/Open_source) project that I am creating with my friends and fellow Durham Computer Science students, [@Muirey03](https://github.com/Muirey03) and [@MohammedMohsinAhmed](https://github.com/MohammedMohsinAhmed). Our aim is to create a ray-based rendering engine written in [JavaScript](https://en.wikipedia.org/wiki/JavaScript). The repository for this, [MiniRay](https://github.com/Muirey03/MiniRay), is now live.

## What have I learned?
I have started to research ray-based rendering and, in particular, the differences between [ray casting](https://en.wikipedia.org/wiki/Ray_casting), [ray tracing](https://en.wikipedia.org/wiki/Ray_tracing_(graphics)), and [ray marching](https://en.wikipedia.org/wiki/Volume_ray_casting). The distinction between the three is a [very interesting topic](https://blog.ruofeidu.com/tutorial-of-ray-casting-ray-tracing-and-ray-marching/) on its own. The application of all three methods can create amazing results, especially when [using ray marching](https://www.youtube.com/watch?v=9U0XVdvQwAI).

## What will I do next?
I will begin working on some form of ray-based rendering algorithm with my fellow collaborators, and I will continue my research into appropriate implementations. I want to take particular care to understand the entire code base, in particular the contributions made by my friends. Hopefully, this will prove to be a helpful exercise in code reading, something that I should definitely practise more.